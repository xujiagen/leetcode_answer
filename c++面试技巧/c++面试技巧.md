### c++ 面试技巧

1. new/delete 和 malloc/free之间的区别
   二者都可以动态的创建和撤销内存
   new/delete是运算符，指向效率高， 后者是标志函数库
   new/delete会调用对象的构造函数和析构函数, 后者不会
   new 返回的是变量类型的指针, malloc返回的是void类型的指针

2. delete和 delete [] 之间的区别
   后者是delete处理数组的方法，他会调用数组里面的每一个对象的析构函数，然后释放内容
   new/delete成对使用, new[] / delete[] 成对使用

3. c++ 的特征？
   封装，继承，多态

4.  子类析构时会调用父类的析构函数吗？
   会，子类析构时调用的顺序是： 先调用派生类的析构函数，然后调用基类的析构函数, 子类在创建的时候首先调用基类的构造函数，然后调用派生类的构造函数

5. c++ 的多态靠什么实现？
   广义上的重载包括静态多态和动态多态
   静态多态通过函数/运算符重载实现，体现在程序编译的时候，通过单行语句就可以判断调用的哪个程序（输入参数的类型和个数）
   动态多态是通过虚函数来实现， 单凭一行代码难以确定是调用了哪个函数， 必须结合上下文进行判断

6. 虚函数的作用？
   在基类中通过virtual标记的基类函数例如virtual void display(), 允许在派生类中重写(override), 函数类型，名，参数必须一样，最好也加上virtual关键字,同时重写的函数依旧自动被标记成virtual类型

   通过虚函数和一个指向基类对象类型的指针进行配合，能够方便的调用同一个类族中的不同class的同名函数，只需要改变指针的指向即可

7. 纯虚函数和虚函数之间的区别, 纯虚函数的作用是什么？
   纯虚函数没有函数体， virtual void display() = 0;
   拥有纯虚函数的类称之为抽象类， 抽象类不能定义对象(及不能实例化)
   纯虚函数的作用是为一个类族提供一个公共接口

8. 引用和指针的区别？
   引用是一个变量的别名， 而指针是一个变量，指向的是另外一个变量的地址
   引用不占用内存， 申明一个引用不是定义了一个新的变量
   引用在定义的时候必须初始化， 并且以后不能赋值改变其做其他变量的别名，而指针不是必须需要初始化，也可以随时赋值
   指针可以为null, 而引用不可以为null
   不能建立数组的引用，意思是数组的元素不能是引用，但是数组名可以被引用
   sizeof引用得到的是所指向变量的大小， sizeof指针得到的是指针本身的大小
   指针可以有很多级， 但是引用只能有一级

9. 将引用作为函数参数的特点？
    可以作为输出参数，可以实现多变量输出
    避免了值传递导致的的大量的数据拷贝

10. 什么时候使用常引用？
    既利用了引用提高了程序的效率，又保护数据在传递的过程中不会被修改

11. 将引用作为函数返回值的格式，好处， 要准守的规则？
    在内存中不会产生返回值的副本
    可以将函数作为左值运算
    ```
    int vals[10];
    int &put(int n) {
        return vals[n];
    }
    int main(int argc, char** argv) {
        put(0) = 10;
        std::cout << vals[0] << std::endl;
    }
    ```

12. struct 和 onion的区别？
    二者都是由不同的数据类型组成， 但是在任何同一时刻， union中只存放了一个被选中的成员， 而struct中所有成员都在。
    sizeof(struct) = sizeof(all), sizeof(union) = sizeof(max(all))
    对于联合的不同成员赋值， 会对其成员进行重写， 原来的成员的值就不存在了

13. 重载，重写，影藏的区别？ (overload, override, overwrite)
14. 什么时候必须使用初始化列表初始化对象？
    1.类的成员有const修饰
    2.类的成员为引用
    3.类的成员缺少默认的构造函数
    4.派生类在初始化时， 会在其初始化列表中调用其基类的默认构造函数

15. c++是不是类型安全的？
    不是，不同类型的指针之间可以进行强制转换

16. main函数执行前会执行什么代码？
    全局对象的构造函数会在main之前进行

17. 分别写出bool, int, float， 指针类型的变量a和“零”的比较
    
18. const和define的区别
    const变量与数据类型， define宏常量没有数据类型， 编译器会对const 变量的数据类型进行检查，而对define变量只是对程序中的变量进行替换

19.内存分配的几种方式？
    1.从静态存储区域分配， 内存在程序编译时就已经分配好了，这块内存在程序整个运行过程中都存在， 例如全局变量， 静态局部变量
    2. 在执行函数时， 函数内局部变量的存储单元都在栈上面创建的， 函数执行结束后，这些存储单元都会被销毁
    3. 堆上面创建元素， 也称之为动态创建， 程序在运行时用malloc或者new进行创建， 程序员自己负责在什么时候进行free/delete释放内存， 动态内存的生存期限由我们决定

19-2.由c/c++编译的程序占用的内存分为几个部分？

20. 基类的析构函数不是虚函数，会有什么结果？
    当使用基类指针， 去指向派生类对象进行一些操作时，如果基类的析构函数不是虚函数， 当delete pt只会执行基类的析构函数， 不会执行派生类的析构函数

21.static的作用？
    对普通的变量/函数?
    静态局部变量： 对普通的变量和函数， 存储位置从栈改为静态存储区， 默认初始化为0， 作用域没有改变， 仍然是本函数体， 但是离开函数体之后， 没有被销毁，仍然保留在内存中， 直到程序结束， 所以程序结束前再次进入函数，static类型的变量还是上一次计算结束的值
    静态全局变量： 存储区和生命周期并未改变， 改变的是作用域， 普通全局变量作用域是整个工程
    static函数: 作用域限制在本文件中， 即便在其头文件声明后， 也不能在这个头文件包含的文件中使用这个static函数， static函数在内存中只有一份

    对类：
    静态成员变量：用static修饰的成员变量会在该类的所有对象中共享，包括派生类的对象
    static成员必须在域外进行初始化
    静态成员函数：
    用static修饰的成员函数，使这个类只存在这一份函数， 所有的对象共享该函数， 不含this指针
    其意义在于访问静态成员变量， 因为静态成员函数不含有this指针， 所以不能访问非静态成员变量。
    可以通过类名进行访问，无对象也可以， 也可以通过对象访问。

22. const和static为什么不能同时修饰成员变量？
    const修饰成员变量，为了保证修饰的函数不能修改成员变量，会对修饰的成员函数的输入参数this加入const 进行修饰， 但是static 修饰成员变量是该成员变量不会传入this,这两者是冲突的

23. const 的作用有哪些？
    1.限制变量不可以被修改
    2. 限制成员函数不可以修改任何数据成员
    3. const 与 指针：
        const char* p;
        char* const p;
        const char* const p;
    
24. 多重继承和虚继承
25. vector中 size()和capacity()的区别？
    