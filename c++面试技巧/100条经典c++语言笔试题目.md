1. 某文件中定义的静态全局变量，其作用域是？ 本文本
2. 如何判断一段程序是c编译器编译的还是c++的编译器编译的？
   ```
   #ifdef __cplusplus
        std::cout << "c++";
    #else 
        std::cout << "c";
   ```
   看程序编译的时候，上面的编译器的编译的宏可以判断编译器是哪种

3. ```
   class A {
       virtual void func1();//虚函数
       void func2();//常函数
   }

   class B : class A {
       void func1(){}//虚函数是重写，不是虚函数
       virtual void func2(){}//是虚函数
   }
   ```
   virtual 提示该函数是虚函数， 同时体现了一个动态绑定的效果

4. c和c++有什么不同？
   1. 语法， 2.特性 3. 场景 4. 效率
   2. 从机制上： c是面向过程的(但是c也可以编写面向对象的程序)， c++是面向对象的，提供了类，c++编写面向对象的程序比c容易
   3. 从适用的方向： c适合要求代码体积小， 效率高的场景， 入嵌入式， c++更适合上层，复杂的， linux大部分的代码是c写的，因为他是系统软件， 效率要求更高
   4. 从名称上， c++是c的超集， 

5. c和c++中struct有什么区别？
   在c中struct是一种自定义的变量类型， 不可以定义函数， 但是可以有函数指针， 同时外界对struct中数据有无限制的访问权限
   c++ 可以保护我们的数据不可以被访问， 可以定义函数

6. c++ struct和class有什么区别？
   1.默认的继承权限 class 继承按照private继承处理， struct的继承按照public继承处理
   2. 成员的默认访问权限，class的成员默认是private权限， struct默认是public权限
7. int id[sizeof(unsigned long)] 这个对吗？ 为什么？ 正确， 编译是就确定了unsigned long的长度

8. "new" in c++ is 运算符
9. 变量的指针含义是变量的？ 地址
10. 多态的作用? 隐藏实现的细节， 使得代码更加模块化， 拓展代码模块， 实现代码的复用
    接口重用： 为了类在继承和派生的时候， 保证使用家族中任意一类的实例的某一属性时的正确调用。

11. 多态类中的虚函数表是compile-time, 还是run-time时建立的？
    虚函数表是在编译的时候就建立的， 各个虚拟函数这个时候被组织成了一个虚拟函数的入口地址的数组， 而对象的隐藏成员-虚拟函数表指针是在运行的时候，也就是构造函数被调用的时候进行初始化的， 这个是实现多态的关键。(编译的时候构建虚函数表，执行的时候根据虚函数表来判断导致执行哪一个函数)

12. 面向对象的三个基本特征， 并且简单叙述？
    1. 封装 -> 通过class/struct 实现 public, protected, private等方法，实现保护和隔离
    2. 继承，主要是为了复用。
    3. 多态
13. 内联函数在编译时是否做参数类型检查？ 内联函数需要做参数类型检查， 这是内联函数和宏相比的优势
14. 内存分配方式有几种方法？ 
15. 对于一个频繁使用的短小函数， 在c语言中应用什么实现， 在c++中应用什么实现？
    c是用宏定义， c++用inline->是建议编译器编译成内联函数

16. 全局变量和局部变量有什么区别？ 是怎么实现的？ 操作系统和编译器是怎么知道的？
    局部变量使用时创建， 不使用时销毁， 全局变量 整个程序的生命周期都存在
    空间 局部变量是在函数内部才有用， 全局变量是整个文件内部都有用
    外部链接： 局部变量是肯定不能外部链接的， 全局变量是可以通过extern 来进行外部链接
    内存分配： 局部变量内存分配在栈中， 全局变量分配在全局数据区


17. 用c++ 写一个程序， 如何判断一个操作系统是16位还是32位？
    定义一个指针类型的变量， 打印出sizeof(p), 如果sizeof(p) == 4 32位(如果不能使用sizeof不能使用，判断int类型的最大值来判断)

18. 为什么需要堆， 使用堆空间的原因？
    使用堆主要是为了可以实现动态申请，直到运行的时候才直到某些数据的长度

19. 若数组名作为实参，而指针变量作为形参， 函数调用实参传递给形参的是？ 数组的第一个元素的地址(一般数组传参需要数组的第一个元素的地址和数组的长度)
20. 有了malloc/free为什么还要new/delete？
21. 为什么数组名作为参数， 会改变数组的内容，但是形参本身是数组的第一个元素的地址？
22. 讲一讲析构函数和虚函数的用法和作用？析构函数是特殊的类成员函数， 它没有重载， 没有返回类型， 没有返回参数， 不能随意的调用， 也没有重载，只有在类对象的生命周期结束的时候，由系统自身调用， 有释放内存空间的作用， 虚函数时c++多态的一种表现， 使用虚函数，我们可以灵活的进行动态绑定， 当然也会存在多余的开销。(类在继承的时候，父类的析构函数是虚函数)

23. 转义字符是? "\"后面可以跟三个八进制数和两个十六进制数或者“\\”
24. 引用和指针有什么区别？
25. 在c++ 中有没有纯虚构造函数？ 没有
26. 多次多次fclose一个打开过一次的FILE *fp指针会有什么结果, 请解释一下？
    多次打开同一个文件，但是fp所在的内存可能会被分配给其他的文件，导致打开的时候出错，根本原因是c在进行打开的时候没有检查这个指针的地址有没有被修改。(c语言对内存的检查非常的简单)

27. 重载(overload), 重写(override), 重定义(影藏redefinition)的区别？
    对于类来说，其内部的成员函数名称是一样的，但是输入的参数的类型，数量，返回值是不一样的，称之为重载
    对于虚函数来说， 父类的一个函数， 子类存在一个同名的函数，且输入参数的数量和返回值的类型都是一样的，称之为重写
    对于继承来说， 父类定义了一个函数，子类也创建了同一个函数， 会对父类的同名函数进行覆盖和屏蔽，称之为重定义

28. c++是不是类型安全的？ 类型安全是指对于不同类型的数据能不能进行转换
29. c++里面是不是所有的动作都是main()引起的？ 全局变量的初始化
30. 是不是一个父类写了一个virual函数, 如果子类覆盖它的函数不加virtual,也能实现多态？ 可以，virtual是隐士继承的
31. ```
    void func() {
        static int val; 
    }中,变量val的内存地址位于 ？ 
    ```
    已初始化的数据段

32. 如何打印当前源文件的文件名以及源文件的当前的行号？ 
    标准答案： std::cout << __FILE__; 当前文件的文件名 
    std::cout << __LINE__; 当前所在的行号
    std::cout << __FUNC__;当前调用的函数的函数名


33. 当一个类A中没有申明任何成员变量与成员函数， 这个时候sizeof(A) 的值是多少， 请解释一下编译器为什么没有让它为0
34. 在排序方法中， 关键码比较次数与记录地初始排序无关的是? 选择排序
35. 函数模板和类模板有什么区别？ 函数模板的实例化是由编译程序在处理函数调用的时候自动完成的， 而类模板的实例化必须由程序员在程序中显式的指定
36. 函数重载，我们通过什么区别哪个函数？ 靠函数的返回值进行判断行不行？
37. 所有的运算符都能重载吗？ 不能被重载的标识符(. # @ $)
38. 基类的析构函数不是虚函数， 会带来什么问题？ 
39. 介绍一下模板和容器，如何实现？ 模板是c++中泛型编程的机制， 容器是vector, list, deque, map(键值对), multimap, set, multiset
40. 深拷贝和浅拷贝之间的区别？
41. 在类中如何使用const？const修饰函数返回值表示该值不能作为左值
42. 写出判断a,b,c,d四个表达式的是否是正确的， 若正确， 写出租经过表达式中a的值, int a = 4; 
    A. a += (a++) B. a+= (++a) C. (a++) += a D. (++a) =+ (a++)
    c是错误的，a++不能作为左值，++a可以作为左值

43. 谈谈使用return的语句？ 
44. 三元操作符？之后的两个变量应该是同一个数据类型·
45. 写一个能做左值的函数， 例如 max(x, y) += 2874 + 55; drwline(x, y)++;
46. 对于调用的虚函数和模板类都有迟后编译
47. 基类和子类中函数如果要构成虚函数， 除了要求在基类中使用virtual声明外， 而且必须名字也相同， 参数也相同，但是返回值不一定需要相同
48. 内联函数可以为虚函数
49. c++的空类，默认产生构造函数, 拷贝构造函数， 析构函数， 赋值函数， 取址函数， 取地址函数的重载函数
    ```
    class Empty {
        public:
        Empty(); 缺省构造函数
        Empty(const Empty&) 拷贝构造函数
        ~Empty() 虚构函数
        Empty &operator(const Empty&);  赋值函数
        Empty& operator&(); 取址函数
        const Empty* operator&() const; const取址函数
    }
    ```